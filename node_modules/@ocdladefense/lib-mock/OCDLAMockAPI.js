import { ISODate } from "../date/ISODate.js";
import { HttpMock } from "../http/HttpMock.js";
import { Url } from "../http/Url.js";
import { DateRange } from "../date/DateRange.js";
export { OCDLAMock };

let section10 = "813.010 Driving under the influence of intoxicants; penalty. (1) A person commits the offense of driving while under the influence of intoxicants if the person drives a vehicle while the person:";

let sectiond = "(d) Within two hours after driving a vehicle, and without consuming alcohol in the intervening time period, has 0.08 percent or more by weight of alcohol in the blood of the person, as shown by chemical analysis of the breath or blood of the person made under ORS 813.100, 813.140 or 813.150.";

let chapter813 = {section10, sectiond};

class OCDLAMock extends HttpMock {
    //https://www.googleapis.com/calendar/v3/calendars/biere-library@thebierelibrary.com/events?timeMin=2023-07-01&timeMax=2023=07-15&test
    errors = {
        'success': false,
        'error': 'Invalid request!'
    };

    getResponse(req) {
        let url = new Url(req.url);
        let data = [];
        //pretend we have parsed the url
        let query = url.getQuery();
        // gets section and chapter
        // 

        try {
            if (query.timeMin && !ISODate.isValid(query.timeMin)) {
                throw new RangeError("invalid date range", { cause: "INVALID_RANGE" });
            }
            if (query.timeMax && !ISODate.isValid(query.timeMax)) {
                throw new RangeError("invalid date range", { cause: "INVALID_RANGE" });
            }
            data = this.filterEvents(query.timeMin, query.timeMax);

        } catch (e) {
            data = {
                success: false,
                error: true,
                code: e.cause,
                message: e.message
            };
        }



        return Response.json(data);
    }

    /*
    eventSort(a, b) {
        let aTime = new Date(a.start.date || a.start.dateTime);
        let bTime = new Date(b.start.date || b.start.dateTime);
    
        if (aTime < bTime) {
            return -1;
        } else if (aTime > bTime) {
            return 1;
        }
        return 0;
    }
    */

    // Should be able to take both OR either of timeMin, timeMax.
    filterEvents(timeMin, timeMax) {

        timeMin = !timeMin ? null : new Date(timeMin);
        timeMax = !timeMax ? null : new Date(timeMax);
        let range = timeMin && timeMax ? new DateRange(timeMin, timeMax) : null;

        function fn(event) {
            // these variables should eventually be a separate function to process localization
            // ternary to check if dateTime exists; if exists, get the year-month-day part of the string. if not, get normal date.
            let startString = event.start.date || event.start.dateTime.split("T")[0];
            let endString = event.end.date || event.end.dateTime.split("T")[0];

            let eventStart = new Date(startString);
            let eventEnd = new Date(endString);
            if (timeMin && timeMax) {
                return range.isWithinRange(eventStart, eventEnd);
            }
            if (timeMin && !timeMax) {
                return (timeMin <= eventStart) || (timeMin <= eventEnd);
            }
            if (timeMax && !timeMin) {
                return (eventStart <= timeMax) || (eventEnd <= timeMax);
            }

            //return true;
        }

        return events.filter(fn);
    }


}
